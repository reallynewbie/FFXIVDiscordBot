require("dotenv").config();

var mongoose = require("mongoose");
const autoIncrement = require("mongoose-auto-increment");

const Accounts = require("./models/Account");
const Characters = require("./models/Character");

//Set up default mongoose connection
var mongoDB = "mongodb://127.0.0.1/my_database";
mongoose.connect(mongoDB);
// Get Mongoose to use the global promise library
mongoose.Promise = global.Promise;
//Get the default connection
var db = mongoose.connection;

//Init Autoincrement for field accountID and for a model named Accounts.
autoIncrement.initialize(db);
Accounts.schema.plugin(autoIncrement.plugin, {
  model: "Accounts",
  field: "accountID"
})
Characters.schema.plugin(autoIncrement.plugin, {
  model: "Characters",
  field: "charID"
})

//Bind connection to error event (to get notification of connection errors)
db.on("error", console.error.bind(console, "MongoDB connection error:"));

// var accountSchema = new Schema({
//   discordName: String,
//   discordAcctID: String,
//   accountID: Number, (Filled with autoincrement)
//   updateffLogsTrigger: {type: Boolean, default: false}
// });

function addAccount(acctInfo) {

  return new Promise((resolve, reject) => {
    checkNewAccount(acctInfo)
      .then(() => {
        let discordID = acctInfo.discordAcctID;
        findAccount(discordID)
          .then(results => {
            if (results.length == 0) {
              let newAccount = new Accounts.model(acctInfo);
              newAccount.save(function (err, res) {
                if (err) reject(err);
                resolve("addAccount: Save completed");
              });
            } else {
              console.log(results);
              reject("addAccount: Account already exists");
            }
          })
      });
  });
}

function checkNewAccount(acctInfo) {
  return new Promise((resolve, reject) => {
    if (acctInfo.discordAcctID !== undefined) {
      if (acctInfo.discordName !== undefined) {
        resolve("checkNewAccount:  ok params");
      } else {
        reject("checkNewAccount: undefined discordName");
      }
    } else {
      reject("checkNewAccount: undefined discordAcctID");
    }
  })
}

function findAccount(acctID) {
  return new Promise((resolve, reject) => {
    Accounts.model.find({
      discordAcctID: acctID
    }, null, function (
      err,
      account
    ) {
      if (err) reject(err);
      resolve(account);
    });
  })
}
// Obsolete as I'm using awaitmessages to handle the situation, but can be used later.
// function collectorSwitch(acctID) {
//   return new Promise((resolve, reject) => {
//     Accounts.model.findOneAndUpdate({discordAcctID : acctID}, )
//     Accounts.model.findOne({
//       discordAcctID: acctID
//     }, null, function(err, res) {
//       if (err) reject(err);
//       res.collector = !res.collector;
//       res.save((err, updated) => {
//         if (err) reject(err);
//         resolve(updated);
//       })
//     })
//   })
// }

function deleteAccount(acctID) {
  return new Promise((resolve, reject) => {
    Accounts.model.deleteMany({
      discordAcctID: acctID
    }, function (err) {
      if (err)
        reject(err);
      else
        resolve("Account Deleted Successfully");
    })
  })
}

function deleteCharacter(id) {
  return new Promise((resolve, reject) => {
    Characters.model.deleteOne({
      charID: id
    }, function (err) {
      if (err) reject(err);
      else resolve("Character deleted:  ", id)
    })
  })
}

//dateJoined is now in UTC Epoch time - let date = new Date(seconds) 
// let charSchema = new Schema({
//   CharID: Number, (Autogenerated)
//   Jobs: Array,
//   AccountID: String,
//   dateJoined: Number,
//   lastUpdate: Number,
//   CharFName: String,
//   CharLName: String,
//   fflogs: String
// });

function addNewCharacter(inDiscordID, jobArray, nameArray, inFFlogs) {
  return new Promise((resolve, reject) => {
    //Need a check to see if a discordID is already linked.(Will need to support people with alts)
    let curDate = Date.now();
    let newCharacter = new Characters.model({
      jobs: jobArray,
      discordID: inDiscordID,
      dateJoined: curDate,
      lastUpdated: curDate,
      charFName: nameArray[0].charAt(0).toUpperCase() + nameArray[0].substr(1),
      charLName: nameArray[1].charAt(0).toUpperCase() + nameArray[1].substr(1),
      fflogs: inFFlogs
    });
    newCharacter.save((err, res) => {
      if (err) reject(err);
      resolve("addNewCharacter:  Save Successful");
    });
  })
}

async function findCharacter(id) {
  return new Promise((resolve, reject) => {
    Characters.model.find({
      discordID: id
    }, function (err, res) {
      if (err) reject(err);
      resolve(res);
    })
  })
}

async function addEXP(discID, jobArray) {
  return new Promise((resolve, reject) => {
    Characters.model.findOne({
      discordID: discID
    }, async (err, res) => {
      if (err) {
        reject(Error(err));
      } else {
        let pulledJobArray = res.jobs;
        await jobArray.forEach(element => {
          let index = pulledJobArray.findIndex(e2 => {
            return e2.job == element.job
          })
          if (index != -1) {
            //console.log(pulledJobArray[index], element.exp)
            pulledJobArray[index].exp += element.exp;
          } else {
            pulledJobArray.push({
              job: element.job,
              exp: element.exp
            })
          }
        });
        //console.log(pulledJobArray);
        res.jobs = []; // overwrite jobs with the new jobarray
        res.jobs = pulledJobArray;

        resolve(res.save());
      }
    })
  })
}


module.exports = {
  addAccount,
  findAccount,
  deleteAccount,
  addNewCharacter,
  findCharacter,
  addEXP
};
// addAccount({
//     discordAcctID: "fff",
//     discordName: "ffff"
//   }).then(msg => {
//     console.log(msg);
//   })
//   .catch(err => {
//     console.log("ERR DETECTEED", err);
//   });
console.log("Mongoosedb Completed");